[{"title":"自动选择声音输出","url":"%2F2018%2F08%2F06%2F%E8%87%AA%E5%8A%A8%E9%80%89%E6%8B%A9%E5%A3%B0%E9%9F%B3%E8%BE%93%E5%87%BA%2F","content":"\n由于我的MacBook pro 接着显示器，显示器上有声音输出，而且又使用了boom2软件，当我插入耳机打算听音乐的时候每次都需要选择声音的输出，真的是很麻烦，我打算把这个转换输出的操作自动化。\n\n> 目标：每次当audio有变化时，选择耳机选项，如果没有耳机选择则什么都不做。\n\n用AppleScript实现如下：\n\n```\ntell application \"System Preferences\"\n\tactivate\n\tset current pane to pane \"com.apple.preference.sound\"\nend tell\n\ntell application \"System Events\"\n\ttell application process \"System Preferences\"\n\t\trepeat until exists tab group 1 of window \"Sound\"\n\t\tend repeat\n\t\ttell tab group 1 of window \"Sound\"\n\t\t\tclick radio button \"Output\"\n\t\t\ttell table 1 of scroll area 1\n\t\t\t\tif (exists (row 1 where value of text field 1 is \"Headphones\")) then\n\t\t\t\t\tdisplay notification \"change output to Headphones\"\n\t\t\t\t\tselect (row 1 where value of text field 1 is \"Headphones\")\n\t\t\t\telse\n\t\t\t\t\tdisplay notification \"not change any output\"\n\t\t\t\tend if\n\t\t\tend tell\n\t\tend tell\n\tend tell\nend tell\n```\n\n脚本的难点是判断Headphones选项，`exists (row 1 where value of text field 1 is \"Headphones\")` \n\n![](https://ws1.sinaimg.cn/large/71d9c3dcgy1fu0cgc2wzvj210y0rmgoc)\n\n苹果的选择区域分别为scroll area  -> table  -> row -> text field\n\n具体的操作实现了，还剩下触发事件。\n\n这个时候就要用到keyboard Masetro了,选择一个trigger `The audio output device changes`再执行上面的脚本，搞定！\n\n![](https://ws1.sinaimg.cn/large/71d9c3dcgy1fu0cq1mnb9j20rm0y67al)","tags":["AppleScript"]},{"title":"gradle版本冲突","url":"%2F2018%2F02%2F25%2Fgradle%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%2F","content":"\n### Transitive\n\ngradle的依赖管理默认具有传递性，A依赖B，B依赖C，则A依赖C。\n\n也可以将这项配置关闭，这样A所依赖的B和C需要手动添加。\n\n```groovy\n//整个项目取消依赖传递\nconfigurations.all {\n  transitive = false\n}\n//单个依赖取消依赖传递\ndependencies {\n  compile ('group:name:version') {\n    transitive = false\n  }\n}\n```\n\n### 依赖冲突\n\n如果D也依赖C，而且B依赖的C的版本为1.0，D依赖的C的版本为2.0\n\ngradle会如何选择？\n\n默认选择最新版本，不会报错。所以在默认配置下，依赖会生产冲突。\n\n依赖冲突的解决方法应该是定制化的。\n\n+ #### Force\n\n  强制设置某个版本\n\n  ```groovy\n  //整个项目统一使用某个版本\n  configurations.all {\n    resolutionStrategy {\n      force 'group:c:1.0'\n    }\n  }\n  //特定依赖使用某个版本\n  dependencies {\n    compile ('group:B:version') {\n      force 'group:C:1.0'\n    }\n  }\n  ```\n\n  ​\n\n+ #### exclude\n\n去除某个依赖，其实就会使用没有去处的依赖的版本，也可以使依赖一致。\n\n```groovy\ndependencies {\n  compile ('group:D:version) {\n    exclude 'group:C'\n  }\n}\n```\n\n","tags":["-gradle"]},{"title":"@Autowired和@Resource","url":"%2F2018%2F02%2F10%2FAutowired%E5%92%8CResource%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB%2F"},{"url":"%2F2018%2F01%2F24%2F%E4%B8%A4%E5%8F%AA%E5%B0%8F%E7%8C%AA%2F","content":"##  两只小猪\n\n在一个猪场里，两只小猪诞生了。\n\n猪大从小就知道自己要做一只土猪，可以在更好的环境中生活，每天吃蔬菜水果。于是，他每天控制食量，坚持锻炼。终于在选拔的时候，成功地被选为土猪，进去土猪基地生活。而猪二却相反，他觉得猪就应该每天吃吃睡睡喝喝，有空的时候看看隔壁的小花猪猪，每天活得那么累，还是猪么？虽然在和猪大的聊天中，也挺羡慕猪大现在的生活，可是他很清楚自己最想要的是什么。\n\n一晃几年过去了，猪大和猪二在超市的生鲜部重逢。一个贴着土猪50元/斤，一个贴着家猪13元/斤。"},{"title":"2018第一天","url":"%2F2018%2F01%2F01%2F2018%E7%AC%AC%E4%B8%80%E5%A4%A9%2F","content":"\n![跳跃](http://ozt4iu9i2.bkt.clouddn.com//18-1-1/59215903.jpg)\n\n2018年的第一天，杭州的阳光明媚，麦兜正在自己的窝里晒着太阳，一切都安好。\n\n过去的2017，工作上依旧没有建树，但是每一天也过的充实，在工作中对中后端的实践，算是react入了门，再捣鼓了下vue，都能安心地运行。年末，易控脂的项目，重拾了java，开始java web的实践，技术上小小转变，却带来了思想上的大大进步。以前的自己，总是秉着“学以致用”的原则，觉着项目能安稳地跑在线上，就万事大吉了。技术是为业务服务的，是工具，会使用就行。至于技术本身，点到即止。现在发现是“项目限制了我的想象力”，之前接触的项目几乎不存在性能问题，这让我没有深入技术的理由。当项目开始有要求，需要调优的时候，我绞尽脑汁，却束手无策。只有当你完全了解一个事情，掌握来龙去脉，你才会觉得自己能够控制它，心里不会忐忑不安，因为你知道哪里会有什么问题，出现问题了怎么解决。说回技术，前端的圈子像是娱乐圈，每天争奇斗艳，八卦不断，让人眼花缭乱，很是热闹，井喷式的发展，让我有点迷失了方向。但是，入门简单，很容易上手，寥寥几断代码，就能所见即所得，让人成就感爆棚。后端则就寂寞地多，几百行的代码，密密麻麻，感觉每一行代码哪里都很简单，组合在一起却苦涩难懂。其实这些都是表面的，任何复杂的系统，不管是前端还是后端，对于入门者来说会有各种各样的感受，但是拨开云雾，看清里面的世界，其实就是简单的一花一木，不就是简单的“hello world”吗？所以不积硅步无以至千里，脚踏实地，写好每个一个“hello world”，才能创造出一个世界！在新的一年里，我希望自己不要眼高手低，夯实基础，把每个环节的知识点都能融会贯通，了解彻底，了然于胸。将工匠精神融入代码中，像猫咪一样，目光坚定，直视前方，百尺竿头更进一步！\n\n生活中，杨雪已经怀孕3个多月，宝宝一直很健康，希望可以平安健康地来到这个世界，我要在接下来的几个月的时间，做好准备，介绍这个美好的世界给她！\n","tags":["-感想"],"categories":["感想"]},{"title":"基于jenkins和docker的spring cloud 微服务持续集成","url":"%2F2017%2F11%2F22%2F%E5%9F%BA%E4%BA%8Ejenkins%E5%92%8Cdocker%E7%9A%84spring-cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F","content":"\n## 准备工作\n\n1. centos 服务器一台 ✔\n\n2. 安装jenkins ✔\n\n3. 安装docker ✔\n\n4. Spring-cloud 项目一个 ✔\n\n   ​\n\n## GitHub 配置\n\n### 配置给jenkins使用的token\n\n[token生成地址](https://github.com/settings/tokens/new)\n\n![](http://ozt4iu9i2.bkt.clouddn.com//17-11-22/59070340.jpg)\n\n","tags":["spring-cloud"]},{"title":"centos安装docker","url":"%2F2017%2F11%2F21%2Fcentos%E5%AE%89%E8%A3%85docker%2F","content":"\n### 系统要求\n\n安装Docker CE 需要版本7以上的64位centos，而且必须启用centos-extras源。\n\n### 卸载旧版本\n\n```bash\nsudo yum remove docker docker-common docker-selinux docker-engine\n```\n\n### 安装DockerCE\n\n#### 通过YUM安装\n\n##### 配置官方源\n\n1. 安装依赖包\n\n   ```Bash\n   sudo yum install -y yum-utils \\\n   device-mapper-persistent-data \\\n   lvm2\n   ```\n\n   ​\n\n2. 配置稳定版本的源\n\n   ```bash\n   sudo yum-config-manager \\\n       --add-repo \\\n       http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo(官方源https://download.docker.com/linux/centos/docker-ce.repo比较慢）\n   ```\n\n##### 安装\n\n```bash\nsudo yum -y install docker-ce\n```\n\n\n\n### 启动docker\n\n```Bash\nsudo systemctl start docker\n```\n\n#### 建立docker用户组\n\n> 默认情况下，`docker` 命令会使用 [Unix socket](https://en.wikipedia.org/wiki/Unix_domain_socket) 与 Docker 引擎通讯。而只有 `root` 用户和 `docker` 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 `root` 用户。因此，更好地做法是将需要使用 `docker` 的用户加入 `docker` 用户组。\n\n```Bash\nsudo groupadd docker\nsudo usermod -aG docker $USER\n```\n\n\n\n### 卸载docker\n\n1. ```bash\n   sudo yum remove docker-ce\n   ```\n\n2. 删除docker相关的文件\n\n   ```Bash\n   sudo rm -rf /var/lib/docker\n   ```\n\n   ​","tags":["docker"]},{"title":"vim插件之surround.vim","url":"%2F2017%2F06%2F21%2Fvim%E6%8F%92%E4%BB%B6%E4%B9%8Bsurround-vim%2F","content":"\n# SURROUND.VIM\n[surround.vim](https://github.com/tpope/vim-surround) 可以快速的选择修改在包围里面的字符串，例如冒号，引号，大括号等\n\n### 主要命令\n+ `cs` 修改\n+ `ds` 删除\n+ `ys` 添加\n\n### 常用例子\n废话不多说，上代码:\n假设有一段字符: `\"hello vim!\"`\n\n输入`cs\"'`\n变成`'hello vim!'`\n\n`cs'<q>`\n=> `<q>hello vim!</q>`\n\n`cst\"`(当包围是多个字符时)\n=> `\"hello vim!\"`\n\n`ds\"`去除\"\n=> `hello vim!`\n\n`ysiw[`iw是一个单词，这里可以使用任何选择\n=> `[ hello ] vim!`\n\n在选择模式下输入S+你需要包围的字符串\n\n### 补充\n+ [和{ 是带空格的，]和}不带空格\n+ 如果你需要使用到`.`命令来重复上面的命令，则需要再添加一个插件[vim-repeat](https://github.com/tpope/vim-repeat)\n","tags":["surround"],"categories":["code"]},{"title":"vim之学习用帮助","url":"%2F2017%2F06%2F20%2Fvim%E4%B9%8B%E5%AD%A6%E4%B9%A0%E7%94%A8%E5%B8%AE%E5%8A%A9%2F","content":"\n## 开始使用\n\n* 在命令模式下输入`:help`开始使用帮助\n* 输入`:h pattern`查看pattern的使用帮助\n\n### 链接\n* <kbd>Ctrl + ]</kbd> 进行超链接跳转\n* <kbd>Ctrl + o</kbd> 跳转到较旧的光标的位置\n* <kbd>Ctrl + T</kbd> 跳转到上一个链接处\n\n### 上下文\n\n每个帮助主题都有上下文\n\n|前缀|例子|上下文|\n|:---:|:---:|:---:|\n|`:`|`:h :r`|命令模式下以冒号开始的命令|\n|无|`:h r`|normal mode|\n|`v_`|`:h v_r`|visual mode|\n|`i_`|`:h i_CTRL-W`|insert mode|\n|`c_`|`:h c_CTRL-R`|ex command line|\n|`/`|`:h /\\r`|正则搜索帮助|\n|`'`|`:h 'ro'`|选项，这里表示以readonly的方式打开|\n|`-`|`:h -r`|参数|\n\n如果你知道 <kbd>ctrl+r</kbd> ，只要在命令行中输入`:h ctrl-r`,然后再按<kbd>ctrl+d</kbd>,vim 会列出所有不同上下文的关键字\n","tags":["help"],"categories":["code"]},{"title":"shortcat使用心得","url":"%2F2017%2F06%2F13%2Fshortcat%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F","content":"\n官网地址: [shortcat](https://shortcatapp.com/)\n\n> kill mice, one at a time.\n\n过度使用trackpad之后，感觉手很累，效率也比较低，开始慢慢成为了键盘党，从此以后手也轻松了，心也舒畅了，妹子们也纷纷投来了崇拜的目光！\n\n\nshortcat能支持绝大多数的应用，基本可以做到脱离鼠标，使我们的效率更高。\n\n![](http://ww1.sinaimg.cn/large/71d9c3dcgy1fgkleq6ng4g20ik0gmasa.gif)\n\n## 常用技巧\n\n* ⎡ ⇧ + ⌘ + space ⎦ 快捷键\n* 支持中文，可以直接打拼音\n* \b\b英文\b标点. 显示所有可以点\b击的区域, .button 显示所有可以点击的按钮\n* \b快速按下2次enter键可以模拟双击\n","tags":["键盘"],"categories":["mac"]},{"title":"vim常用操作","url":"%2F2017%2F02%2F15%2Fvim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F","content":"# Vim快捷键\n---\n## 光标移动\n[vim移动光标文档](http://vimcdoc.sourceforge.net/doc/usr_03.html#usr_03.txt)\n### 在文件中移动\n+ `gg` 移动到第一行\n+ `GG` 移动到最后一行\n+ 命令`G`前面加上数字n即跳转到第n行。\n+ 命令`n%`即按百分比跳转，`50%`->文档中间😄\n<!--more-->\n### 行内移动\n+ `t`移动到光标右边的指定字符之前\n+ `f` 移动到光标右边的指定字符上\n+ `T`移动到光标左边的指定字符之前\n+ `F`移动到光标左边的指定字符上\n+ `0|^`移动到行首0包括空白字符\n+ `$`移动到行尾\n+ `w`下一个单词的词首，大写时包括空格、括号等非单词字符\n+ `b`上一个单词的词首\n+ `e`下一个单词的词尾\n+ `ge`上个单词的词尾\n\n### 括号匹配\n%\n\n### 相对于光标滚屏\nzt|zz|zb 把光标所在的行滚至窗口的顶端、中间、底部😊\n","tags":["vim"]},{"title":"Alfred-iTerm2","url":"%2F2016%2F12%2F16%2FAlfred-iTerm2%2F","content":"# Alfred 中将iTerm2 设置成默认的terminal\n* 打开`Alfred Preferences`  - `Features` - `Terminal / Shell`\n* 更改`Application`为`Customer`\n* 替换成以下代码:\n\n```shell\non alfred_script(q)\ntell application \"System Events\"\n    tell application \"iTerm2\"\n        create window with default profile\n        delay 0.5\n        tell current session of current window\n            write text q\n        end tell\n    end tell\nend tell\n\nend alfred_script\n```\n\n👌\n\n[参考]('https://github.com/tridays/alfred-iterm2')\n","tags":["iTerm2"]},{"title":"css实现文本截断","url":"%2F2016%2F12%2F14%2Fcss%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E6%88%AA%E6%96%AD%2F","content":"\n`text-overflow: clip|ellipsis|string`\n\n值 | 描述\n---|---\nclip | 修剪文本直接截断\nellipsis | 用省略号代替截断的字符串\nstring | 使用给出的字符串来代替截断的字符串([兼容性差,只有火狐支持](\"https://developer.mozilla.org/en-US/docs/Web/CSS/text-overflow\"))\n\nhere we go\n\n{% jsfiddle b08zsgqd/2 %}\n\n> * clip 会比 ellipsis 显示更多的字符\n> * `display`需要是`block`\n> * 配合`white-space: nowrap` 强制不换行来使用\n","tags":["css"]},{"title":"ssh配置","url":"%2F2016%2F12%2F13%2Fssh%E9%85%8D%E7%BD%AE%2F","content":"\n# ssh 配置\n\n利用ssh远程连接服务器命令：\n```shell\nssh user@hostname -p port\n\n```\n\n每次输入hostname，又麻烦又难记，所以可以在～/.ssh/config中配置host\n\n```shell\n\tHost 别名\n\t\tHostName 主机ip\n\t\tProt 端口（默认则无需配置）\n\t\tUser 登陆用户名\n\t\tIdentityFile 登陆密钥文件（免密码登录时需要）\n```\n\n下次登录是只要输入`ssh 别名` +密码就能登录\n","tags":["mac"],"categories":["config"]},{"title":"border详解","url":"%2F2016%2F11%2F24%2Fborder%E8%AF%A6%E8%A7%A3%2F","content":"### border-width\n> `border-width` 因为边框的语义决定了宽度不能用百分比表示，类似`box-shadow`\n\n#### 关键字\n* `thin` : `1px`\n* `medium`: `2px`\n* `thick`: `5px`\n<!--more-->\n\n### border-style\n常用的有`solid`(实线)， `dashed`(虚线)， `double`(双线，3px才有效果,双线宽度永远相等，中间间隔+-1), `dotted`(点线比虚线更密)\n> 由于border的兼容性比较好，经常用作一些图形的替代方案\n\n三条杠\n```css\n  {\n    width: 120px;\n    height: 20px;\n    border-top: 60px double;\n    border-bottom: 20px solid;\n  }\n```\n\n### border-color\n> 当没有制定border-color时会使用color作为边框颜色\n\n### 应用\n\n三角形：利用容器宽高为0时每个边框由三角形组成一个正方形，两边透明就变成了一个规则的三角形，可以有各种组合\n```css\n.triangle {\n  width: 0px;\n  height: 0px;\n  border: 100px solid;\n  border-color: transparent red red transparent;\n}\n```\n梯形：隐藏另外三边，给容器增加宽度就能得到梯形\n\n```css\n.trapezoid {\n  width: 50px;\n  border: 4px solid;\n  border-color: transparent transparent red;\n}\n```\n布局的应用： 等高布局\n```css\n.box {\n  border-left: 300px solid #c3c3c3;\n}\n\n.left {\n  width: 300px;\n  margin-left: -300px;\n  float: left;\n}\n\n```\n","tags":["css"]},{"title":"linux常用命令","url":"%2F2016%2F11%2F23%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F","content":"\n`alsamixer` 声卡配置 按`m`键开关配置\n","tags":["linux"]},{"title":"字符编码详解","url":"%2F2016%2F11%2F19%2F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%AF%A6%E8%A7%A3%2F","content":"\n>原文出处:[Justin Huang 的博客(@Justin_Programer)](http://sharecore.net/blog/2014/08/10/zi-fu-bian-ma-chang-shi-ji-wen-ti-jie-xi/)\n\n# 基本常识\n### 1.位和字节\n位（bit）是指计算机里存放的二进制值(0/1)，而8个位组合成的“位串”称为一个字节，容易算出，8个位的组合有256个组合方式，其取值范围是“00000000-11111111”，常用十六进制来表示。比如“01000001”就是一个字节，其对应的十六进制值为“0x41”。\n而我们通常所讲的字符编码，就是指定义一套规则，将真实世界里的字母/字符与计算机的二进制序列进行相互转化。如我们可以针对上面的字节定义如下的转换规则：\n`01000001（0x41）<-> 65 <-> A`\n即用字位序`01000001`来表示字母`A`。\n<!--more-->\n### 2.拉丁字符\n拉丁字符是当今世界使用最广泛的符号了。通常我们说的拉丁字母，指的的是基础拉丁字母,即指常见的”ABCD“等26个英文字母，这些字母与英语中一些常见的符号（如数字，标点符号）称为基础拉丁字符，这些基础拉丁字符在使用英语的国家广为流行，当然在中国，也被用来当作汉语拼音使用。在欧洲其它一些非英语国家，为满足其语言需要，在基础拉丁字符的基础上，加上一些连字符，变音字符(如`Á`)，形成了派生拉丁字母，其表示的字符范围在各种语言有所不同，而完整意义上的拉丁字符是指这些变体字符与基础拉丁字符的全集。是比基础拉丁字符集大很多的一个集合。\n\n***\n# 编码标准\n## 1.拉丁编码\nASCII的全称是American Standard Code for Information Interchange（美国信息交换标准代码）。顾名思义，这是现代计算机的发明国美国人设计的标准，而美国是一个英语国家，他们设定的ASCII编码也只支持基础拉丁字符。ASCII的设计也很简单，用一个字节（8个位）来表示一个字符，并保证最高位的取值永远为’0’。即表示字符含义的位数为7位，不难算出其可表达字符数为27 =128个。这128个字符包括95个可打印的字符（涵盖了26个英文字母的大小写以及英文标点符号能）与33个控制字符（不可打印字符）。例如下表，就是几个简单的规则对应:\n\n  |*字符类型*|*字符*|*二进制*|*16进制*|*10进制*|\n  |----------|------|--------|--------|--------|\n  |可打印字符|`A`|`01000001`|`0x41`|`65`|\n  |可打印字符|`a`|`01100001`|`0x61`|`97`|\n  |控制字符|`\\r`|`00001101`|`0x0D`|`13`|\n  |控制字符|`\\n`|`00001010`|`0xA`|`10`|\n***\nASCII是美国人设计的，只能支持基础拉丁字符，而当计算机发展到欧洲，欧洲其它不只是用的基础拉丁字符的国家（即用更大的派生拉丁字符集）该怎么办呢？\n\n当然，最简单的办法就是将美国人没有用到的第8位也用上就好了，这样能表达的字符个数就达到了28 =256个，相比较原来，增长了一倍， 这个编码规则也常被称为`EASCII`。`EASCII`基本解决了整个西欧的字符编码问题。但是对于欧洲其它地方如北欧，东欧地区，256个字符还是不够用，如是出现了`ISO 8859`,为解决256个字符不够用的问题，`ISO8859`采取的不再是单个独立的编码规则，而是由一系列的字符集（共15个）所组成，分别称为`ISO8859-n`(n=1,2,3…11,13…16,没有12)。其每个字符集对应不同的语言,如`ISO 8859-1`对应西欧语言，`ISO 8859-2`对应中欧语言等。其中大家所熟悉的`Latin-1`就是`ISO8859-1`的别名,它表示整个西欧的字符集范围。需要注意的一点的是，`ISO8859-n`与`ASCII`是兼容的，即其`0000000(0x00)-01111111(0x7f)`范围段与ASCII保持一致，而`10000000（0x80）-11111111(0xFF)`范围段被扩展用到不同的字符集。\n\n## 2.中文编码\n以上我们接触到的拉丁编码，都是单字节编码，即用一个字节来对应一个字符。但这一规则对于其它字符集更大的语言来说，并不适应，比如中文，而是出现了用多个字节表示一个字符的编码规则。常见的中文`GB2312`（国家简体中文字符集）就是用两个字节来表示一个汉字（注意是表示一个汉字，对于拉丁字母，`GB2312`还是是用一个字节来表示以兼容`ASCII`）。我们用下表来说明各中文编码之间的规则和兼容性。\n\n|<br />|*GB2312*|*BIG5*|*GBK*|*GB18030*|\n|------|--------|------|-----|---------|\n|作用|国家简体中文字符集|统一繁体字符集|GB2312的扩展，加入对繁体字的支持|中日韩文字编码|\n|字节数|变字节:<br />1字节-兼容ASCII<br />2字节-汉字|2字节|2字节|变字节:<br />1字节-兼容ASCII<br />2字节，4字节|\n|范围|7445字符，6763汉字|21886字符|21886字符|27484字符|\n|兼容性|兼容ASCII|兼容ASCII但和GB2312冲突|兼容GB2312|兼容GB2312|\n***\n对于中文编码，其规则实现上是很简单的，一般都是简单的字符查表即可，重要的是要注意其相互之间的兼容性问题。如如果选择BIG5字符集编码，就不能很好的兼容GB2312，当做繁转简时有可能导致个别字的冲突与不一致，但是GBK与GB2312之间就不存在这样的问题。\n\n## 3.Unicode\n针对不同的语言采用不同的编码，有可能导致冲突与不兼容性，如果我们打开一份字节序文件，如果不知道其编码规则，就无法正确解析其语义，这也是产生乱码的根本原因。有没有一种规则是全世界字符统一的呢？当然有，`Unicode`就是一种。为了能独立表示世界上所有的字符，`Unicode`采用4个字节表示一个字符,这样理论上`Unicode`能表示的字符数就达到了2^31= 2147483648 = 21 亿左右个字符，完全可以涵盖世界上一切语言所用的符号。我们以汉字”微信“两字举例说明：\n>微 &lt;-&gt; `\\u5fae` &lt;-&gt; `00000000 00000000 01011111 10101110`\n>信 &lt;-&gt; `\\u4fe1` &lt;-&gt; `00000000 00000000 01001111 11100001`\n\n容易从上面的例子里看出，Unicode对所有的字符编码均需要四个字节，而这对于拉丁字母或汉字来说是浪费的，其前面三个或两个字节均是0,这对信息存储来说是极大的浪费。另外一个问题就是，如何区分Unicode与其它编码这也是一个问题，比如计算机怎么知道四个字节表示一个Unicode中的字符，还是分别表示四个ASCII的字符呢？\n***\n以上两个问题，困扰着`Unicode`，让`Unicode`的推广上一直面临着困难。直至`UTF-8`作为`Unicode`的一种实现后，部分问题得到解决，才得以完成推广使用。说到此，我们可以回答文章一开始提出的问题了，`UTF-8`是`Unicode`的一种实现方式，而`Unicode`是一个统一标准规范，`Unicode`的实现方式除了`UTF-8`还有其它的，比如`UTF-16`等。\n\n话说当初大牛*Ben Thomson*吃饭时，在一张餐巾纸上，设计出了`UTF-8`，然后回到房间，实现了第一版的`UTF-8`。关于`UTF-8`的基本规则，其实简单来说就两条（来自阮一峰老师的总结）:\n\n规则1：对于单字节字符，字节的第一位为`0`，后7位为这个符号的`Unicode`码，所以对于拉丁字母，`UTF-8`与`ASCII`码是一致的。\n\n规则2：对于`n`字节(`n>1`)的字符，第一个字节前`n`位都设为`1`，第`n+1`位为`0`，后面字节的前两位一律设为`10`，剩下没有提及的位，全部为这个符号的`Unicode`编码。\n\n通过，根据以上规则，可以建立一个Unicode取值范围与UTF-8字节序表示的对应关系，如下表:\n\n|*Unicode字符范围（十六进制）*|*UTF-8编码方式（二进制）*|\n|-----------------------------|-------------------------|\n|单字节:`0000 0000-0000 007F`|`0xxxxxxx`|\n|双字节:`0000 0080-0000 07FF`|`110xxxxx 10xxxxxx`|\n|三字节:`0000 0800-0000 FFFF`|`1110xxxx 10xxxxxx 10xxxxxx`|\n|四字节:`0001 0000-0010 FFFF`|`11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`|\n***\n举例来说，’微’的Unicode是`\\u5fae`，二进制表示是`00000000 00000000 01011111 10101110`，其取值就位于`0000 0800-0000 FFFF`之间，所以其`UTF-8`编码为`11100101 10111110 10101110`。\n\n通过以上简单规则，`UTF-8`采取变字节的方式，解决了我们前文提到的关于`Unicode`的两大问题。同时，作为中文使用者需要注意的一点是**`Unicode(UTF-8)`与`GBK`，`GB2312`这些汉字编码规则是完全不兼容的，也就是说这两者之间不能通过任何算法来进行转换,如需转换，一般通过`GBK`查表的方式来进行。**\n","tags":["ASCII"]},{"title":"chmod命令","url":"%2F2016%2F11%2F19%2Fchmod%E5%91%BD%E4%BB%A4%2F","content":"## linux chmod 命令\nchmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。\nLinux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。\n文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。\n有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。\n<!--more-->\n每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。 例如：\n命令：\n`ls -al`\n输出：\n```\n  root@localhost test]# ll -al\n  总计 316lrwxrwxrwx 1 root root     11 11-22 06:58 linklog.log -> log2012.log\n  -rw-r--r-- 1 root root 302108 11-13 06:03 log2012.log\n  -rw-r--r-- 1 root root     61 11-13 06:03 log2013.log\n  -rw-r--r-- 1 root root      0 11-13 06:03 log2014.log\n  -rw-r--r-- 1 root root      0 11-13 06:06 log2015.log\n  -rw-r--r-- 1 root root      0 11-16 14:41 log2016.log\n  -rw-r--r-- 1 root root      0 11-16 14:43 log2017.log\n```\n我们以log2012.log为例：\n`-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log`\n第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。从第二个字符开始到第十个共9个字符，3个字符一组，分别表示了3组用户对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。\n例如：\n　　`- rw- r-- r--`\n　　表示log2012.log是一个普通文件；log2012.log的属主有读写权限；与log2012.log属主同组的用户只有读权限；其他用户也只有读权限。\n\n　　确定了一个文件的访问权限后，用户可以利用Linux系统提供的chmod命令来重新设定不同的访问权限。也可以利用chown命令来更改某个文件或目录的所有者。利用chgrp命令来更改某个文件或目录的用户组。\nchmod命令是非常重要的，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。chmod命令详细情况如下。\n\n 1.命令格式:\n`chmod [-cfvR] [--help] [--version] mode file`\n 2.命令功能：\n用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。\n 3.命令参数：\n必要参数：\n-c 当发生改变时，报告处理信息\n-f 错误信息不输出\n-R 处理指定目录以及其子目录下的所有文件\n-v 运行时显示详细处理信息\n选择参数：\n--reference=<目录或者文件> 设置成具有指定目录或者文件具有相同的权限\n--version 显示版本信息\n<权限范围>+<权限设置> 使权限范围内的目录或者文件具有指定的权限\n<权限范围>-<权限设置> 删除权限范围的目录或者文件的指定权限\n<权限范围>=<权限设置> 设置权限范围内的目录或者文件的权限为指定的值\n权限范围：\nu ：目录或者文件的当前的用户\ng ：目录或者文件的当前的群组\no ：除了目录或者文件的当前用户或群组之外的用户或者群组\na ：所有的用户及群组\n权限代号：\nr ：读权限，用数字4表示\nw ：写权限，用数字2表示\nx ：执行权限，用数字1表示\n-：删除权限，用数字0表示\ns ：特殊权限\n该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。\n　　- 文字设定法:\n　　\t`chmod ［who］ ［+ | - | =］ ［mode］ 文件名`\n　　- 数字设定法\n　　我们必须首先了解用数字表示的属性的含义：0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）。\n　　例如，如果想让某个文件的属主有“读/写”二种权限，需要把4（可读）+2（可写）＝6（读/写）。\n　　数字设定法的一般形式为：\n　　\tchmod ［mode］ 文件名\n数字与字符对应关系如下：\nr=4，w=2，x=1\n若要rwx属性则4+2+1=7\n若要rw-属性则4+2=6；\n若要r-x属性则4+1=5。\n 4. 使用实例：\n实例1：增加文件所有用户组可执行权限\n命令：\n`chmod a+x log2012.log`\n输出：\n```\n  [root@localhost test]# ls -al log2012.log\n  -rw-r--r-- 1 root root 302108 11-13 06:03 log2012.log\n  [root@localhost test]# chmod a+x log2012.log\n  [root@localhost test]# ls -al log2012.log\n  -rwxr-xr-x 1 root root 302108 11-13 06:03 log2012.log\n  [root@localhost test]#\n```\n说明：\n　　即设定文件log2012.log的属性为：文件属主（u） 增加执行权限；与文件属主同组用户（g） 增加执行权限；其他用户（o） 增加执行权限。\n　\n实例2：同时修改不同用户权限\n命令：\n`chmod ug+w,o-x log2012.log`\n输出：\n```\n  [root@localhost test]# ls -al log2012.log\n  -rwxr-xr-x 1 root root 302108 11-13 06:03 log2012.log\n  [root@localhost test]# chmod ug+w,o-x log2012.log\n  [root@localhost test]# ls -al log2012.log\n  -rwxrwxr-- 1 root root 302108 11-13 06:03 log2012.log\n```\n","tags":["linux"]}]